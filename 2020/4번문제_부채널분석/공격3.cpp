
// 실행조건
// ReadingC 함수 안의 fopen 함수의 암호문 파일 위치 입력 필요

#include <iostream>
#pragma warning(disable:4996)

unsigned char IV[16]; // 초기화 벡터
unsigned char LastKey[16] = { 0x22,0xE5,0x00,0xA1,0xE9,0x39,0x00,0x4C,0x00,0xA5,0x5B,0x2C,0x00,0x9B,0x3E,0x00 }; // 10 라운드 키, 모르는 key(10,2), key(10,6), key(10,8), key(10,12), key(10,15) 0x00으로 두었음.
unsigned char CipherText[1025][16]; // 암호문
unsigned char PlainText[1025][16]; // 평문
unsigned char state[16]; // 중간값
unsigned char answer[8] = { 0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1 }; // 평문의 첫번째 블럭의 제일 앞 8바이트
unsigned char Key[11][16]; // 0~10라운드 키
unsigned char t[4];
int counting = 0;
unsigned char rsbox[256] = // sbox 역원
{ 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb
    , 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb
    , 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e
    , 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25
    , 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92
    , 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84
    , 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06
    , 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b
    , 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73
    , 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e
    , 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b
    , 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4
    , 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f
    , 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef
    , 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61
    , 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };

unsigned char Rcon[255] = { // Rcon 상수값
    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
    0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
    0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
    0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
    0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
    0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
    0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
    0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
    0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
    0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
    0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
    0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
    0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
    0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
    0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb };

unsigned char sbox[256] = { // sbox
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };

unsigned char aaa, bbb, ccc;

// 10라운드 키 -> 0라운드 키가지 키 역생성
void InvKeySchedule(void) {
    for (int i = 0; i < 16; i++) {
        Key[10][i] = LastKey[i];
    }
    for (int i = 0; i < 10; i++) {
        for (int j = 3; j > 0; j--) {
            for (int k = 0; k < 4; k++) {
                Key[9 - i][4 * j + k] = Key[10 - i][4 * j + k] ^ Key[10 - i][4 * (j - 1) + k];
            }
        }
        t[0] = Key[9 - i][12];
        t[1] = Key[9 - i][13];
        t[2] = Key[9 - i][14];
        t[3] = Key[9 - i][15];
        unsigned char temp = t[0];
        t[0] = t[1];
        t[1] = t[2];
        t[2] = t[3];
        t[3] = temp;

        t[0] = sbox[t[0]];
        t[1] = sbox[t[1]];
        t[2] = sbox[t[2]];
        t[3] = sbox[t[3]];

        t[0] = t[0] ^ Rcon[10 - i];

        Key[9 - i][0] = t[0] ^ Key[10 - i][0];
        Key[9 - i][1] = t[1] ^ Key[10 - i][1];
        Key[9 - i][2] = t[2] ^ Key[10 - i][2];
        Key[9 - i][3] = t[3] ^ Key[10 - i][3];
    }
    return;
}

// InvMixColumns 매크로 함수
#define xtime(x)   ((x<<1) ^ (((x>>7) & 1) * 0x1b))
#define Multiply(x,y) (((y & 1) * x) ^ ((y>>1 & 1) * xtime(x)) ^ ((y>>2 & 1) * xtime(xtime(x))) ^ ((y>>3 & 1) * xtime(xtime(xtime(x)))) ^ ((y>>4 & 1) * xtime(xtime(xtime(xtime(x))))))



// InvMixColumns 함수
void InvMixColumns(void) {
    unsigned char aa, bb, cc, dd;
    for (int i = 0; i < 4; i++) {
        aa = state[i * 4 + 0];
        bb = state[i * 4 + 1];
        cc = state[i * 4 + 2];
        dd = state[i * 4 + 3];


        state[i * 4 + 0] = Multiply(aa, 0x0e) ^ Multiply(bb, 0x0b) ^ Multiply(cc, 0x0d) ^ Multiply(dd, 0x09);
        state[i * 4 + 1] = Multiply(aa, 0x09) ^ Multiply(bb, 0x0e) ^ Multiply(cc, 0x0b) ^ Multiply(dd, 0x0d);
        state[i * 4 + 2] = Multiply(aa, 0x0d) ^ Multiply(bb, 0x09) ^ Multiply(cc, 0x0e) ^ Multiply(dd, 0x0b);
        state[i * 4 + 3] = Multiply(aa, 0x0b) ^ Multiply(bb, 0x0d) ^ Multiply(cc, 0x09) ^ Multiply(dd, 0x0e);


    }
}

// InvKeyAddition 함수
void InvAdditionKey(int round) {
    for (int i = 0; i < 16; i++) {
        state[i] = state[i] ^ Key[round][i];
    }
}

// InvShiftRows 함수
void InvShiftRows(void) {
    unsigned char temp = state[13];
    unsigned char temp1;
    state[13] = state[9];
    state[9] = state[5];
    state[5] = state[1];
    state[1] = temp;

    temp = state[2];
    state[2] = state[10];
    state[10] = temp;
    temp = state[6];
    state[6] = state[14];
    state[14] = temp;

    temp = state[3];
    state[3] = state[7];
    temp1 = state[15];
    state[15] = temp;
    temp = state[11];
    state[11] = temp1;
    state[7] = temp;

}

// InvSubBytes 함수
void InvSubbytes(void) {
    for (int i = 0; i < 16; i++) {
        state[i] = rsbox[state[i]];
    }
}

// 암호문 읽어오는 함수
void ReadingC(void) {
    FILE* fp = fopen("exam.txt", "rb"); // 파일 위치 입력 필요
    for (int i = 0; i < 1025; i++) {
        for (int j = 0; j < 16; j++) {
            CipherText[i][j] = getc(fp);
        }
    }
}

int main(void) {
    ReadingC();

    // 키 찾는 과정
    // key(10,2) ^ key(10,6) = 0x8B
    // key(10,8) & key(10,12) = 0xA8
    // 이므로 
    // key(10,2) = a, key(10,6) = a ^ 0x8B
    // key(10,8) = b, key(10,12) = b ^ 0xA8
    // key(10,15) = c
    // 로 두고 복호화하였을 때 첫번째 평문 8바이트가 문제에서 주어진 것과 일치하는지 확인하면 됨
    for (int a = 0; a < 256; a++) {
        for (int b = 0; b < 256; b++) {
            for (int c = 0; c < 256; c++) {

                LastKey[2] = a;
                LastKey[6] = a ^ 0x8B;
                LastKey[8] = b;
                LastKey[12] = b ^ 0xA8;
                LastKey[15] = c;

                //복호화도 첫번째 암호문 블럭만 진행
                InvKeySchedule();
                for (int i = 0; i < 16; i++) {
                    state[i] = CipherText[0][i];
                }
                InvAdditionKey(10);
                InvShiftRows();
                InvSubbytes();
                for (int j = 9; j > 0; j--) {
                    InvAdditionKey(j);
                    InvMixColumns();
                    InvShiftRows();
                    InvSubbytes();
                }
                InvAdditionKey(0);

                // 제일 첫번째 8바이트가 동일한지 확인
                counting = 0;
                for (int l = 0; l < 8; l++) {
                    if (answer[l] == state[l]) counting++;
                }
                // 첫번째 8바이트가 동일할 경우 모든 암호문에 대해 복호화 진행
                if (counting == 8) {
                    for (int k = 0; k < 1025; k++) {
                        for (int i = 0; i < 16; i++) {
                            state[i] = CipherText[k][i];
                        }
                        InvAdditionKey(10);
                        InvShiftRows();
                        InvSubbytes();
                        for (int j = 9; j > 0; j--) {
                            InvAdditionKey(j);
                            InvMixColumns();
                            InvShiftRows();
                            InvSubbytes();
                        }
                        InvAdditionKey(0);
                        for (int i = 0; i < 16; i++) {
                            PlainText[k][i] = state[i] ^ IV[i];
                        }
                        for (int i = 0; i < 16; i++) {
                            IV[i] = CipherText[k][i];
                        }
                    }
                    // 복호화한 파일을 출력함.
                    FILE* fz = fopen("result.hwp", "wb");
                    for (int i = 0; i < 1025; i++) {
                        for (int j = 0; j < 16; j++) {
                            fputc(PlainText[i][j], fz);

                        }
                    }
                    printf("key(10,2) = 0x%X, key(10,6) = 0x%X, key(10,8) = 0x%X, key(10,12) = 0x%X, key(10,15) = 0x%X\n복호화 종료\n", a, a ^ 0x8B, b, b ^ 0xA8, c);
                    return 0;
                }
            }
        }
    }
}

